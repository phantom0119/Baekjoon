# 백준 15829 Hashing 브론즈2
'''
문자열에는 영문 소문자(a, b, ..., z)로만 구성되어있다고 가정하자. 
영어에는 총 26개의 알파벳이 존재하므로 a에는 1, b에는 2, c에는 3, ..., 
z에는 26으로 고유한 번호를 부여할 수 있다.

하나의 문자열을 수열로 변환할 수 있다. 
예를 들어서 문자열 "abba"은 수열 1, 2, 2, 1로 나타낼 수 있다.

 
\[H = \sum_{i=0}^{l-1}{a_i} \mod M\] 

r과 M은 서로소인 숫자로 정하는 것이 일반적이다. 
직접 정하라고 하면 힘들테니까 r의 값은 26보다 큰 소수인 31로 하고 
M의 값은 1234567891(놀랍게도 소수이다!!)로 하자.


첫 줄에는 문자열의 길이 L이 들어온다. 
둘째 줄에는 영문 소문자로만 이루어진 문자열이 들어온다.
입력으로 주어지는 문자열은 모두 알파벳 소문자로만 구성되어 있다.

문제에서 주어진 해시함수와 입력으로 주어진 문자열을 사용해 
계산한 해시 값을 정수로 출력한다.

'''
from math import sqrt
Alpha_Dict = {'a':1, 'b':2, 'c':3, 'd':4, 'e':5, 'f':6, 'g':7,
            'h':8, 'i':9, 'j':10, 'k':11, 'l':12, 'm':13, 'n':14,
            'o':15, 'p':16, 'q':17, 'r':18, 's':19, 't':20, 'u':21,
            'v':22, 'w':23, 'x':24, 'y':25, 'z':26}
M = 1234567891
L = int(input())
string_h = input()
total = 0

for idx, alp in enumerate(string_h):
    #print(f"{Alpha_Dict[alp]=}, {31**idx}")
    total += Alpha_Dict[alp] * 31**idx

print(total%M)
    
